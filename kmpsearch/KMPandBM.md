#1.算法解释

假设现在文本串`S`匹配到`i`位置，模式串`P`匹配到`j`位置

* 如果`j = -1`，或者当前字符匹配成功（即`S[i] == P[j]`），都令`i++`，`j++`，继续匹配下一个字符；
* 如果`j != -1`，且当前字符匹配失败（即`S[i] != P[j]`），则令i不变，`j = next[j]`。此举意味着失配时，模式串P相对于文本串S向右移动了`j - next[j]`位。

换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next
值，即移动的实际位数为：`j - next[j]`，且此值大于等于1。

很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果`next [j] = k`，代表j之前的字符串中有最大长度为k的相同前缀后缀。此也意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到
`next[j]`的位置）。如果`next[j]`等于0或-1，则跳到模式串的开头字符，若`next [j] = k`且`k > 0`，代表下次匹配跳到j之前的某个字符，而不是跳到开头，且具体跳过了k个字符。

#2.求next数组

已知`next[0, ..., j]`，如何求出`next[j + 1]`呢？

对于pattern的前j+1个序列字符：

* 若`pattern[k] == pattern[j]`，则`next[j + 1] = next [j] + 1 = k + 1`；
* 若`pattern[k] ≠ pattern[j]`，如果此时`pattern[next[k]] == pattern[j]`，则`next[j + 1] = next[k] + 1`，否则继续递归重复此过程。相当于在字符`p[j + 1]`之前不存在长度为`k + 1`的前缀"p0 p1, …, pk-1 pk"跟后缀"pj-k pj-k+1, …, pj-1 pj"相等，那么是否可能存在另一个值t+1 < k+1，使得长度更小的前缀"p0 p1, …, pt-1 pt"等于长度更小的后缀"pj-t pj-t+1, …, pj-1 pj"呢？如果存在，那么这个`t+1`便是`next[j+1]`的值，此相当于利用next数组进行P串前缀跟P串后缀的匹配。

#3.Next数组的优化

当`p[j] != s[i]`时，下次匹配必然是`p[next[j]]`跟`s[i]`匹配，如果`p[j] = p[next[j]]`，必然导致后一步匹配失败，所以不能允许`p[j] = p[next[j]]`。

```c
//优化过后的next 数组求法
void GetNextval(char* p, int next[])
{
	int pLen = strlen(p);
	next[0] = -1;
	int k = -1;
	int j = 0;
	while (j < pLen - 1)
	{
		//p[k]表示前缀，p[j]表示后缀
		if (k == -1 || p[j] == p[k])
		{
			++j;
			++k;
			//较之前next数组求法，改动在下面4行
			if (p[j] != p[k])
				next[j] = k; //之前只有这一行
			else
				//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]
				next[j] = next[k];
		}
		else
		{
			k = next[k];
		}
	}
}
```

#4.KMP的时间复杂度分析

我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是`i++`、`j++`；如果匹配失配，i不变（即i不回溯），模式串会跳过匹配过的`next[j]`个字符。整个算法最坏的情况是，当模式串首字符位于`i - j`的位置时才匹配成功，算法结束。

所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为`O(n)`，算上计算next的`O(m)`时间，KMP的整体时间复杂度为`O(m + n)`。

#5.扩展：BM算法

1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，该算法从模式串的尾部开始匹配，且拥有在最坏情况下`O(N)`的时间复杂度。在实践中，比KMP算法的实际效能高。

BM算法定义了两个规则：

* 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1。
* 好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。

详细实现可见代码`bmsearch.c`。

来自：http://blog.csdn.net/v_july_v/article/details/7041827
